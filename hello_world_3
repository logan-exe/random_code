
/**
 * Generate a professional PDF by capturing each dashboard widget using native JS SVG-to-canvas.
 * @param {Object} options
 * @param {string} options.title        - Title for the first page.
 * @param {'portrait'|'landscape'} [options.orientation='portrait']
 * @param {Array} options.tabs          - Array of [tabId, { tabTitle, dashboardItems }].
 * @param {string} [options.fileName='document.pdf']
 */
export async function generatePDF({
  title,
  orientation = 'portrait',
  tabs = [],
  fileName = 'document.pdf',
}) {
  const pdf = new jsPDF({ orientation, unit: 'pt', format: 'a4' });
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();
  const bg = '#262626';
  const fg = '#FFFFFF';

  // Title page
  pdf.setFillColor(bg);
  pdf.rect(0, 0, pageW, pageH, 'F');
  pdf.setTextColor(fg);
  pdf.setFontSize(36);
  pdf.text(title, pageW / 2, pageH / 2, { align: 'center' });

  // TOC placeholder
  pdf.addPage();
  const toc = [];

  // Helper: inline computed styles
  function inlineStyles(element) {
    const cs = window.getComputedStyle(element);
    for (let i = 0; i < cs.length; i++) {
      const prop = cs[i];
      element.style.setProperty(prop, cs.getPropertyValue(prop), cs.getPropertyPriority(prop));
    }
    Array.from(element.children).forEach(child => inlineStyles(child));
  }

  // Helper: capture element via SVG foreignObject
  async function captureElementNative(el) {
    const rect = el.getBoundingClientRect();
    const cloned = el.cloneNode(true);
    // inline computed styles for faithful rendering
    inlineStyles(cloned);
    const xml = new XMLSerializer().serializeToString(cloned);
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="${rect.width}px" height="${rect.height}px">
        <foreignObject width="100%" height="100%">${xml}</foreignObject>
      </svg>`;
    const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const img = new Image();
    return new Promise((resolve, reject) => {
      img.onload = () => {
        URL.revokeObjectURL(url);
        const canvas = document.createElement('canvas');
        canvas.width = rect.width * 2;
        canvas.height = rect.height * 2;
        const ctx = canvas.getContext('2d');
        ctx.scale(2, 2);
        ctx.drawImage(img, 0, 0);
        resolve(canvas);
      };
      img.onerror = reject;
      img.src = url;
    });
  }

  // Process each tab and widget
  for (const [tabId, tabObj] of tabs) {
    const { tabTitle, dashboardItems } = tabObj;
    pdf.addPage();
    const pageNum = pdf.getNumberOfPages();
    toc.push({ title: tabTitle, page: pageNum });

    // Section header
    pdf.setFillColor(bg);
    pdf.rect(0, 0, pageW, pageH, 'F');
    pdf.setTextColor(fg);
    pdf.setFontSize(24);
    pdf.text(tabTitle, 40, 60);
    let y = 90;

    for (const item of dashboardItems) {
      const key = item.widgetState?.key;
      const widgetEl = document.getElementById(key);
      if (!widgetEl) {
        console.warn(`Missing element: ${key}`);
        continue;
      }
      // Native capture
      const canvas = await captureElementNative(widgetEl);
      const dataURL = canvas.toDataURL('image/png');
      const w = pageW - 80;
      const h = (w * canvas.height) / canvas.width;
      if (y + h > pageH - 40) {
        pdf.addPage();
        pdf.setFillColor(bg);
        pdf.rect(0, 0, pageW, pageH, 'F');
        y = 60;
      }
      if (item.widgetState?.title) {
        pdf.setFontSize(14);
        pdf.text(item.widgetState.title, 40, y);
        y += 20;
      }
      pdf.addImage(dataURL, 'PNG', 40, y, w, h);
      y += h + 30;
    }
  }

  // Populate TOC (page 2)
  pdf.setPage(2);
  pdf.setFillColor(bg);
  pdf.rect(0, 0, pageW, pageH, 'F');
  pdf.setTextColor(fg);
  pdf.setFontSize(28);
  pdf.text('Table of Contents', pageW / 2, 80, { align: 'center' });
  pdf.setFontSize(14);
  let ty = 120;
  toc.forEach(e => {
    pdf.text(e.title, 60, ty);
    pdf.text(`${e.page}`, pageW - 60, ty, { align: 'right' });
    ty += 24;
  });

  // Page numbers
  const total = pdf.getNumberOfPages();
  pdf.setFontSize(10).setTextColor(fg);
  for (let i = 1; i <= total; i++) {
    pdf.setPage(i);
    if (i > 1) pdf.text(`Page ${i - 1} of ${total - 1}`, pageW - 60, pageH - 30, { align: 'right' });
  }

  pdf.save(fileName);
}

// Changes:
// 1. Removed html2canvas dependency and imports.
// 2. Added captureElementNative() using SVG <foreignObject> -> Image -> Canvas.
// 3. Inlined computed styles for accurate rendering.
// 4. Unified logic into a single generatePDF() function.
